#!/usr/bin/env python
"""
MIT License

Copyright (c) 2019 Piotr Styk <polfilm@gmail.com>

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""
# To align and also continue on active loop (not waiting for speed up)
# Required: Count-In: None, Wrapped Loop, Auto-Wrap: On, Default Wrap: Beats, Create Fades on Clips: On

# TRACK #2 VST_DEVICE (midi chain)
# TRACK #3 NAME SETS CATEGORY "4BARS_<CATEGORY>"

# TRACK #1 CONTROL MESSAGES
# Required 5 steps at 0B (some control, some as placeholders for counts to match, partial bar can't make work)
# [4BARS] 3/MUTE ON; WAITS 0B ; SCENE >
# [4BARS] 3/IN "VST_DEVICE" ; WAITS 0B ; SCENE >
# [4BARS] 3/MON OFF ; WAITS 0B ; SCENE >
# [4BARS] 2/MUTE OFF; WAITS 0B ; SCENE >
# [4BARS] 3/ARM ON ; WAITS 0B ; SCENE 10

# Scenes 10+ AutoGenerated with REFCFIX (4, X) - where X corresponds to track we're on
# WAITS before and after are for effects to wind up/down (pre + 4bars + post = 8bars)
# [4BARS] WAITS 3B; 3/RECFIX 4 X; WAITS 5B; SCENE >


import live
import os
import yaml
import yamlordereddictloader
from fourbars.alive.locations import Locations
from fourbars.mid.mc_midi import *
from fourbars.alive.mc_clip_list import McClipList
from fourbars.alive.parser_track import ParserTrack
from prompt_toolkit import prompt
#import readchar

class Struct:
    def __init__(self, **entries):
        self.__dict__.update(entries)





class ImportClip(object):

    set = None
    track = None
    clip = None
    sub_args = None
    locations = None

    def __init__(self, in_sub_args):
        self.locations = Locations()
        self.sub_args = in_sub_args

        try:
            self.connect()
        except live.LiveConnectionError as e:
            print(e)
            exit(1)
        #self.debug_track_access_assume_first_is_midi()

    def connect(self):
        self.set = live.Set()
        self.set.scan(scan_clip_names = True, scan_devices = True)

    def set_tempo(self, in_tempo):
        self.set.tempo = in_tempo

    def create_empty_scene(self, index):
        """ Creates a new scene by an index. if -1 the scene is created at the end.
         Idea here is always to have same number available so at end is fine."""
        self.set.create_scene(index)

    def create_and_set_clip(self, clip_index):
        self.create_empty_scene_at_end()
        self.set.create_clip(0, clip_index, 16)
        self.set.scan(scan_clip_names=True)
        self.clip = self.set.tracks[0].clips[clip_index]
        print()

    def add_clip_from_mcclip(self, in_clip_index, in_mc_clip):

        self.set.create_clip(0, in_clip_index, in_mc_clip.duration_bars_in_beats)
        self.set.scan(scan_clip_names=True)
        self.clip = self.set.tracks[0].clips[in_clip_index]

        self.set.set_clip_name(0, in_clip_index, in_mc_clip.name)
        try:
            for note in in_mc_clip.clip_notes:
                self.clip.add_note(note.note, note.position, note.duration, note.velocity)
        except:
            pass

    def add_tracks_as_clips(self):


        clip_pos_offset = 7

        mc_clip_list = McClipList(self.sub_args)
        print()



        #self.track = self.set.tracks[0]
        for idx, mc_clip in enumerate(mc_clip_list):

            clip_index = clip_pos_offset + idx
            self.create_empty_scene(clip_index)
            self.add_clip_from_mcclip(clip_index, mc_clip)

            # clip_explored = False  # to initialize for scope
            # while not clip_explored:
            #     clip_explored = False  # to initialize for loop
            #     # print('CONFIRM ACTION: Skip [SPACE], Save [S], Semi [ArUp/ArDown], Shift Sel [ArLeft/ArRight], Tempo [LBrDivide/RBrMultiply] : ')
            #     # print(repr(readchar.readchar()))
            #     answer = prompt('CONFIRM ACTION: Skip [SPACE], Save [S], Semi [ArUp/ArDown], Shift Sel [ArLeft/ArRight], Tempo [LBrDivide/RBrMultiply] : ')
            #     print('You said: %s' % answer)
            #     if answer.upper() == 'S':
            #         clip_explored = True
            #     pass



            # self.create_and_set_clip(clip_index)
            #
            #
            #
            # self.clip.add_note(60, 0, 0.25, 60)
            # self.clip.add_note(60, 1, 0.25, 10)
            # self.clip.add_note(60, 2, 0.25, 120)
            # self.clip.add_note(61, 3, 1, 120)



            # track_index, clip_index, length
            #self.set.create_clip(0, clip_index, 16)
            #self.clip = self.track.clips[clip_index] #TODO: track clips is not refreshed and only holds first clip created (not 2+)

            #ptrack = ParserTrack(trk, mid.ticks_per_beat)

            # note position duration velocity
            """
            :param note:      (int)    MIDI note index
            :param position:  (float)  Position, in beats
            :param duration:  (float)  Duration, in beats
            :param velocity:  (int)    MIDI note velocity
            """
            # for i, note in enumerate(ptrack.clip_notes):
            #     self.clip.add_note(note.note, note.position, note.duration, note.velocity)



        # verify
        #self.debug_clip_access()






    def ctl_insert_record_4bars_at_index(self, index):
        self.set.create_clip(0, index, 4)
        self.set.set_clip_name(0, index, "[4BARS] 3/RECFIX 4 {0} ; WAITS 4B ; SCENE >".format(index))
        device_list = self.set.get_device_list(1)
        device_parameters = self.set.get_device_parameters(1, 0)
        pass

    def debug_track_access_assume_first_is_midi(self):
        self.track = self.set.tracks[0]
        print("Track name %s" % self.track.name)

    def debug_clip_access(self):
        # only if clip exists
        self.clip = self.track.clips[0]
        print("Clip name %s, length %d beats" % (self.clip.name, self.clip.length))

    def play(self):
        self.clip.play()

    def add_clip(self):
        # track_index, clip_index, length
        self.set.create_clip(0, 0, 4)

        # since references by value not ref, we need to reload
        #self.debug_set_access()
        self.add_note()

        # verify
        self.debug_clip_access()

    def add_note(self):

        # if self.sub_args.d:
        #     self.locations.pwd = self.sub_args.d

        #mid = Mid(self.sub_args)
        #mid.load_midi_files()

        # example_file = os.path.join(os.path.dirname(os.path.realpath(__file__)), "ex001.4bars.yaml")
        # data = None
        # if os.path.isfile(example_file):
        #     data = yaml.load(open(example_file), Loader=yamlordereddictloader.Loader)


        print ()
        # note position duration velocity
        self.clip.add_note(60, 0, 0.25, 60)
        self.clip.add_note(60, 1, 0.25, 10)
        self.clip.add_note(60, 2, 0.25, 120)
        self.clip.add_note(61, 3, 1, 120)

    def get_clip(self):
        #clips = self.set.get /live/name/clip
        #track3 = self.set.tracks[2]
        #tempo = self.set.get_tempo()
        #clip10 = self.set.get_clip_name(2, 1)
        #set_filename = self.set._get_last_opened_set_filename()
        #a = self.set.currently_open()

        from randomnames import random_namepair
        print ("random: {}".format(random_namepair()))
        from fourbars.als_parser import AlsParser

        als_filename = '../un/Piotrek173-ClyphxSessions.als.xml'
        alsparser = AlsParser(als_filename)

        for asset in alsparser.track.clipslots:
            print (asset.clip_name, asset.file_abs)
        pass
'''
        import xml.etree.ElementTree as ET
        root = ET.parse('../un/Piotrek173-ClyphxSessions.als.xml').getroot()
        for audiotrack in root.findall('LiveSet/Tracks/AudioTrack'):
            track_name = audiotrack.findall('Name/EffectiveName')[0].get('Value')
            pos = 0
            for clipslot in audiotrack.findall('DeviceChain/MainSequencer/ClipSlotList'):
                pos += 1
                clip_filename = clipslot.findall('ClipSlot/ClipSlot/Value/AudioClip/SampleRef/FileRef/Name')[0].get('Value')
                clip_name = clipslot.findall('ClipSlot/ClipSlot/Value/AudioClip/Name')[0].get('Value')
                clip_fullpath = ""
                for folder in clipslot.findall('ClipSlot/ClipSlot/Value/AudioClip/SampleRef/FileRef/SearchHint/PathHint/RelativePathElement'):
                    clip_fullpath = clip_fullpath + "/" + folder.get('Dir')
                clip_fullpath + "/" + clip_filename
                pass
'''

